import * as assert from 'assert';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';
import { findCSharpSourceFiles } from '../../csharpSourceFinder';

suite('C# Source Finder Test Suite', () => {
    let tempDir: string;
    let projectDirs: string[];

    setup(() => {
        // Create temporary directory for test files
        tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'csharp-source-finder-test-'));
        projectDirs = [];
    });

    teardown(() => {
        // Clean up temporary files
        if (fs.existsSync(tempDir)) {
            fs.rmSync(tempDir, { recursive: true, force: true });
        }
    });

    /**
     * Helper function to create a project directory with source files
     */
    function createProjectDirectory(projectName: string, files: { path: string, content: string }[]): string {
        const projectDir = path.join(tempDir, projectName);
        fs.mkdirSync(projectDir, { recursive: true });

        for (const file of files) {
            const filePath = path.join(projectDir, file.path);
            const fileDir = path.dirname(filePath);
            
            // Create directory structure if needed
            if (!fs.existsSync(fileDir)) {
                fs.mkdirSync(fileDir, { recursive: true });
            }
            
            fs.writeFileSync(filePath, file.content);
        }

        projectDirs.push(projectDir);
        return projectDir;
    }

    /**
     * Helper function to create a .csproj file
     */
    function createCsprojFile(projectDir: string, projectName: string): string {
        const csprojPath = path.join(projectDir, `${projectName}.csproj`);
        const csprojContent = `
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
  </PropertyGroup>
</Project>`;
        fs.writeFileSync(csprojPath, csprojContent);
        return csprojPath;
    }

    test('should find basic C# source files', async () => {
        const project1Dir = createProjectDirectory('Project1', [
            { path: 'Class1.cs', content: 'public class Class1 {}' },
            { path: 'Class2.cs', content: 'public class Class2 {}' },
            { path: 'Subfolder/Class3.cs', content: 'public class Class3 {}' }
        ]);

        const csproj1 = createCsprojFile(project1Dir, 'Project1');

        const result = await findCSharpSourceFiles([csproj1], []);

        assert.ok(result.has('Project1'), 'Should have Project1 entry');
        
        const project1Files = result.get('Project1')!;
        assert.strictEqual(project1Files.length, 3, 'Should find 3 C# files');
        
        const fileNames = project1Files.map(f => path.basename(f)).sort((a, b) => a.localeCompare(b));
        assert.deepStrictEqual(fileNames, ['Class1.cs', 'Class2.cs', 'Class3.cs']);
    });

    test('should handle multiple projects', async () => {
        const project1Dir = createProjectDirectory('Project1', [
            { path: 'Service1.cs', content: 'public class Service1 {}' },
            { path: 'Model1.cs', content: 'public class Model1 {}' }
        ]);

        const project2Dir = createProjectDirectory('Project2', [
            { path: 'Service2.cs', content: 'public class Service2 {}' },
            { path: 'Repository.cs', content: 'public class Repository {}' }
        ]);

        const csproj1 = createCsprojFile(project1Dir, 'Project1');
        const csproj2 = createCsprojFile(project2Dir, 'Project2');

        const result = await findCSharpSourceFiles([csproj1, csproj2], []);

        assert.strictEqual(result.size, 2, 'Should have 2 projects');
        assert.ok(result.has('Project1'), 'Should have Project1');
        assert.ok(result.has('Project2'), 'Should have Project2');
        
        assert.strictEqual(result.get('Project1')!.length, 2, 'Project1 should have 2 files');
        assert.strictEqual(result.get('Project2')!.length, 2, 'Project2 should have 2 files');
    });

    test('should exclude files matching exclude patterns', async () => {
        const projectDir = createProjectDirectory('TestProject', [
            { path: 'ValidClass.cs', content: 'public class ValidClass {}' },
            { path: 'obj/Debug/TempClass.cs', content: 'public class TempClass {}' },
            { path: 'bin/Release/BuildClass.cs', content: 'public class BuildClass {}' },
            { path: 'Generated/AutoGenerated.cs', content: 'public class AutoGenerated {}' },
            { path: 'node_modules/package/Package.cs', content: 'public class Package {}' },
            { path: 'Subfolder/GoodClass.cs', content: 'public class GoodClass {}' }
        ]);

        const csprojPath = createCsprojFile(projectDir, 'TestProject');

        const excludePatterns = [
            '**/obj/**',
            '**/bin/**',
            '**/Generated/**',
            '**/node_modules/**'
        ];

        const result = await findCSharpSourceFiles([csprojPath], excludePatterns);

        const projectFiles = result.get('TestProject')!;
        assert.strictEqual(projectFiles.length, 2, 'Should find only 2 valid files');
        
        const fileNames = projectFiles.map(f => path.basename(f)).sort((a, b) => a.localeCompare(b));
        assert.deepStrictEqual(fileNames, ['GoodClass.cs', 'ValidClass.cs']);
    });

    test('should handle nested directory structures', async () => {
        const projectDir = createProjectDirectory('NestedProject', [
            { path: 'Controllers/HomeController.cs', content: 'public class HomeController {}' },
            { path: 'Controllers/Api/ApiController.cs', content: 'public class ApiController {}' },
            { path: 'Models/User.cs', content: 'public class User {}' },
            { path: 'Models/DTOs/UserDto.cs', content: 'public class UserDto {}' },
            { path: 'Services/UserService.cs', content: 'public class UserService {}' },
            { path: 'Services/External/ExternalService.cs', content: 'public class ExternalService {}' }
        ]);

        const csprojPath = createCsprojFile(projectDir, 'NestedProject');

        const result = await findCSharpSourceFiles([csprojPath], []);

        const projectFiles = result.get('NestedProject')!;
        assert.strictEqual(projectFiles.length, 6, 'Should find all 6 nested files');
        
        // Verify all expected files are found
        const expectedFiles = [
            'HomeController.cs', 'ApiController.cs', 'User.cs', 
            'UserDto.cs', 'UserService.cs', 'ExternalService.cs'
        ];
        const foundFiles = projectFiles.map(f => path.basename(f)).sort((a, b) => a.localeCompare(b));
        expectedFiles.sort((a, b) => a.localeCompare(b));
        
        assert.deepStrictEqual(foundFiles, expectedFiles);
    });

    test('should handle empty projects gracefully', async () => {
        const projectDir = createProjectDirectory('EmptyProject', []);
        const csprojPath = createCsprojFile(projectDir, 'EmptyProject');

        const result = await findCSharpSourceFiles([csprojPath], []);

        assert.ok(result.has('EmptyProject'), 'Should have EmptyProject entry');
        assert.strictEqual(result.get('EmptyProject')!.length, 0, 'Should have no files');
    });

    test('should handle projects with only non-C# files', async () => {
        const projectDir = createProjectDirectory('NonCSharpProject', [
            { path: 'readme.txt', content: 'This is a readme' },
            { path: 'config.json', content: '{}' },
            { path: 'script.js', content: 'console.log("hello");' },
            { path: 'style.css', content: 'body { margin: 0; }' }
        ]);

        const csprojPath = createCsprojFile(projectDir, 'NonCSharpProject');

        const result = await findCSharpSourceFiles([csprojPath], []);

        assert.ok(result.has('NonCSharpProject'), 'Should have NonCSharpProject entry');
        assert.strictEqual(result.get('NonCSharpProject')!.length, 0, 'Should find no C# files');
    });

    test('should handle complex exclude patterns', async () => {
        const projectDir = createProjectDirectory('ComplexProject', [
            { path: 'ValidFile.cs', content: 'public class ValidFile {}' },
            { path: 'TestFile.Test.cs', content: 'public class TestFile {}' },
            { path: 'MockFile.Mock.cs', content: 'public class MockFile {}' },
            { path: 'TempFile.temp.cs', content: 'public class TempFile {}' },
            { path: 'GeneratedFile.designer.cs', content: 'public class GeneratedFile {}' },
            { path: 'AssemblyInfo.cs', content: '[assembly: AssemblyVersion("1.0.0.0")]' },
            { path: 'GlobalUsings.cs', content: 'global using System;' }
        ]);

        const csprojPath = createCsprojFile(projectDir, 'ComplexProject');

        const excludePatterns = [
            '*.Test.cs',
            '*.Mock.cs',
            '*.temp.cs',
            '*.designer.cs',
            'AssemblyInfo.cs'
        ];

        const result = await findCSharpSourceFiles([csprojPath], excludePatterns);

        const projectFiles = result.get('ComplexProject')!;
        assert.strictEqual(projectFiles.length, 2, 'Should find only 2 valid files');
        
        const fileNames = projectFiles.map(f => path.basename(f)).sort((a, b) => a.localeCompare(b));
        assert.deepStrictEqual(fileNames, ['GlobalUsings.cs', 'ValidFile.cs']);
    });

    test('should handle non-existent project directories', async () => {
        const nonExistentCsproj = path.join(tempDir, 'NonExistent', 'NonExistent.csproj');
        
        const result = await findCSharpSourceFiles([nonExistentCsproj], []);

        // Should handle gracefully without throwing
        assert.strictEqual(result.size, 0, 'Should return empty result for non-existent project');
    });

    test('should handle projects with mixed file extensions', async () => {
        const projectDir = createProjectDirectory('MixedProject', [
            { path: 'Class1.cs', content: 'public class Class1 {}' },
            { path: 'Class2.CS', content: 'public class Class2 {}' }, // Different case
            { path: 'NotCSharp.txt', content: 'Not a C# file' },
            { path: 'Script.js', content: 'console.log("test");' },
            { path: 'Interface.cs', content: 'public interface IInterface {}' },
            { path: 'partial.cs', content: 'public partial class Partial {}' }
        ]);

        const csprojPath = createCsprojFile(projectDir, 'MixedProject');

        const result = await findCSharpSourceFiles([csprojPath], []);

        const projectFiles = result.get('MixedProject')!;
        
        // Should find .cs files regardless of case
        const csFiles = projectFiles.filter(f => f.toLowerCase().endsWith('.cs'));
        assert.strictEqual(csFiles.length, 4, 'Should find all .cs files regardless of case');
    });

    test('should handle deep directory nesting', async () => {
        const projectDir = createProjectDirectory('DeepProject', [
            { path: 'Level1/Level2/Level3/Level4/DeepClass.cs', content: 'public class DeepClass {}' },
            { path: 'Level1/Level2/MidClass.cs', content: 'public class MidClass {}' },
            { path: 'RootClass.cs', content: 'public class RootClass {}' }
        ]);

        const csprojPath = createCsprojFile(projectDir, 'DeepProject');

        const result = await findCSharpSourceFiles([csprojPath], []);

        const projectFiles = result.get('DeepProject')!;
        assert.strictEqual(projectFiles.length, 3, 'Should find files at all nesting levels');
        
        const fileNames = projectFiles.map(f => path.basename(f)).sort((a, b) => a.localeCompare(b));
        assert.deepStrictEqual(fileNames, ['DeepClass.cs', 'MidClass.cs', 'RootClass.cs']);
    });

    test('should handle symbolic links gracefully', async () => {
        const projectDir = createProjectDirectory('SymlinkProject', [
            { path: 'RealClass.cs', content: 'public class RealClass {}' }
        ]);

        const csprojPath = createCsprojFile(projectDir, 'SymlinkProject');

        // Try to create a symbolic link (may not work on all systems)
        const realFile = path.join(projectDir, 'RealClass.cs');
        const symlinkFile = path.join(projectDir, 'LinkedClass.cs');
        
        try {
            fs.symlinkSync(realFile, symlinkFile);
        } catch (error) {
            // Symbolic links might not be supported, skip this part of the test
            console.log(`Symbolic links not supported, skipping symlink test: ${error}`);
        }

        const result = await findCSharpSourceFiles([csprojPath], []);

        const projectFiles = result.get('SymlinkProject')!;
        
        // Should handle symbolic links without crashing
        assert.ok(projectFiles.length >= 1, 'Should find at least the real file');
        assert.ok(projectFiles.some(f => path.basename(f) === 'RealClass.cs'), 'Should find the real class');
    });

    test('should handle performance with many files', async () => {
        const fileCount = 100;
        const files: { path: string, content: string }[] = [];

        // Generate many C# files
        for (let i = 0; i < fileCount; i++) {
            files.push({
                path: `Generated/Class${i}.cs`,
                content: `public class Class${i} { }`
            });
        }

        const projectDir = createProjectDirectory('LargeProject', files);
        const csprojPath = createCsprojFile(projectDir, 'LargeProject');

        const startTime = Date.now();
        const result = await findCSharpSourceFiles([csprojPath], []);
        const endTime = Date.now();

        const projectFiles = result.get('LargeProject')!;
        assert.strictEqual(projectFiles.length, fileCount, `Should find all ${fileCount} files`);
        
        // Performance check - should complete within reasonable time
        const executionTime = endTime - startTime;
        assert.ok(executionTime < 3000, `File discovery should complete within 3 seconds, took ${executionTime}ms`);
    });
});