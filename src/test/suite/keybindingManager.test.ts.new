import * as assert from 'assert';
import * as vscode from 'vscode';
import * as sinon from 'sinon';
import { KeybindingManager } from '../../commands/KeybindingManager';

suite('KeybindingManager Test Suite', () => {
    let manager: KeybindingManager;
    let registerCommandStub: sinon.SinonStub;
    let showInformationMessageStub: sinon.SinonStub;
    let showErrorMessageStub: sinon.SinonStub;
    let executeCommandStub: sinon.SinonStub;

    setup(() => {
        // Create stubs for VS Code API
        registerCommandStub = sinon.stub(vscode.commands, 'registerCommand');
        showInformationMessageStub = sinon.stub(vscode.window, 'showInformationMessage');
        showErrorMessageStub = sinon.stub(vscode.window, 'showErrorMessage');
        executeCommandStub = sinon.stub(vscode.commands, 'executeCommand');

        // Mock disposable
        registerCommandStub.returns({ dispose: sinon.stub() });

        manager = KeybindingManager.getInstance();
    });

    teardown(() => {
        sinon.restore();
        KeybindingManager.resetInstance();
    });

    test('should register only basic keybinding commands', () => {
        const mockContext: vscode.ExtensionContext = {
            subscriptions: []
        } as unknown as vscode.ExtensionContext;

        manager.initialize(mockContext);

        // Should register 3 basic commands (modern UI commands are registered elsewhere)
        assert.strictEqual(registerCommandStub.callCount, 3);

        // Verify specific command registrations from actual implementation
        const commandNames = registerCommandStub.getCalls().map(call => call.args[0]);
        assert.ok(commandNames.includes('vscode-csharp-dependency-graph.generate-dependency-graph'));
        assert.ok(commandNames.includes('vscode-csharp-dependency-graph.previewGraphviz'));
        assert.ok(commandNames.includes('vscode-csharp-dependency-graph.analyze-cycles'));
        // Modern UI commands (dependencyGraph.*) are registered in registerModernGraphCommands() in extension.ts
    });

    test('should add commands to extension subscriptions', () => {
        const mockContext: vscode.ExtensionContext = {
            subscriptions: []
        } as unknown as vscode.ExtensionContext;

        manager.initialize(mockContext);

        // Should add 3 disposables to subscriptions (modern UI commands are registered elsewhere)
        assert.strictEqual(mockContext.subscriptions.length, 3);
    });

    test('should enable/disable graph context', () => {
        // Test enabling graph context
        manager.enableGraphContext(true);
        
        // Should call setContext twice
        assert.strictEqual(executeCommandStub.callCount, 2);
        assert.ok(executeCommandStub.calledWith('setContext', 'dependencyGraphActive', true));
        assert.ok(executeCommandStub.calledWith('setContext', 'dependencyGraphHasCycles', true));
        
        executeCommandStub.resetHistory();
        
        // Test disabling graph context
        manager.disableGraphContext();
        
        // Should call setContext twice
        assert.strictEqual(executeCommandStub.callCount, 2);
        assert.ok(executeCommandStub.calledWith('setContext', 'dependencyGraphActive', false));
        assert.ok(executeCommandStub.calledWith('setContext', 'dependencyGraphHasCycles', false));
    });

    test('should get keybindings for context', () => {
        const mockContext: vscode.ExtensionContext = {
            subscriptions: []
        } as unknown as vscode.ExtensionContext;

        manager.initialize(mockContext);
        
        // Test getKeybindings with default context
        const defaultBindings = manager.getKeybindings();
        assert.ok(Array.isArray(defaultBindings));
        
        // Test getKeybindings with specific context
        const editorBindings = manager.getKeybindings('editorTextFocus');
        assert.ok(Array.isArray(editorBindings));
        assert.strictEqual(editorBindings.length, 1); // Only the generate-dependency-graph command has this context
    });

    test('should handle basic command execution', async () => {
        const mockContext: vscode.ExtensionContext = {
            subscriptions: []
        } as unknown as vscode.ExtensionContext;

        manager.initialize(mockContext);

        // Get one of the registered command handlers
        const generateGraphCall = registerCommandStub.getCalls().find(
            call => call.args[0] === 'vscode-csharp-dependency-graph.generate-dependency-graph'
        );
        assert.ok(generateGraphCall, 'generate-dependency-graph command should be registered');

        const handler = generateGraphCall.args[1];
        
        // Execute the handler - it should just log a message
        const consoleSpy = sinon.spy(console, 'log');
        await handler();
        
        // Should have logged the command execution
        assert.ok(consoleSpy.calledWith('Command executed: vscode-csharp-dependency-graph.generate-dependency-graph'));
        
        consoleSpy.restore();
    });

    test('should dispose of registered commands', () => {
        const mockContext: vscode.ExtensionContext = {
            subscriptions: []
        } as unknown as vscode.ExtensionContext;

        // Initialize and register commands
        manager.initialize(mockContext);
        
        // Create a spy to track dispose calls
        const disposeSpy = sinon.spy();
        
        // Replace the registered commands with ones we can track
        const privateManager = manager as unknown as {
            registeredCommands: Map<string, { dispose: () => void }>;
            contextualCommands: Map<string, unknown[]>;
        };
        
        privateManager.registeredCommands.forEach((_, key) => {
            privateManager.registeredCommands.set(key, { dispose: disposeSpy });
        });
        
        const initialSize = privateManager.registeredCommands.size;
        
        // Dispose of all commands
        manager.dispose();
        
        // Should call dispose on each registered command
        assert.strictEqual(disposeSpy.callCount, initialSize);
        
        // Should clear the maps
        assert.strictEqual(privateManager.registeredCommands.size, 0);
        assert.strictEqual(privateManager.contextualCommands.size, 0);
    });
});
